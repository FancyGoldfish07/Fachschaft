Das Kalendersystem ist folgendermaßen aufgebaut: es gibt ein Event, welches die Kalendereintragsdaten vorhält. Sollte der Eintrag sich wiederholen, so wird ein boolean mit Namen repeats gesetzt. Dann wird ein neues Model Recurrence angelegt, welches das Start und Enddatum der Wiederholung speichert. Außerdem kann diese Recurrence eine beliebige Menge an Regeln speichern. Eine Regel besteht aus einem Tag und einer Wochenwiederholung. 1 bedeutet dabei Wiederholung jede Woche und 2 wäre zum Beispiel jede zweite Woche. Wird keine Regel angegeben, ist die Wiederholung nur am Starttag. Aus den Regeln und der Recurrence kann dann mithilfe des ICE_Cube Gems (https://github.com/seejohnrun/ice_cube) jeder Termin der Wiederholung errechnet werden. Das Gem kann dabei deutlich kompliziertere Regeln verarbeiten, aber um eine gute User Experience zu gewährleisten wurde darauf verzichtet. Es gibt allerdings ein Gem, was für diesen Fall ein gutes UI Control bereitstellen würde (https://github.com/GetJobber/recurring_select). Allerdings können diese Regeln so kompliziert werden, dass sie nur noch mit Serialisierung gespeichert werden könnten. Und aus dem zweiten Semester Datenbanken hallt es noch nach dass man nicht in Datenbanken serialisieren sollte. Dementsprechend wurde versucht dies zu vermeiden. Eine Recurrence ihrerseits kann viele Excludes besitzen. Ein Exclude ist einfach ein Datum, an dem die Wiederholung aussetzt. Dies sind unserer Meinung nach sinnvolle Annahmen, die wir getroffen haben. Wenn ein Event veröffentlicht wird, wird bei Wiederholung mit der Methode makeRecurr das Event an den Tagen, wo die Recurrence stattfindet dupliziert. Diese neuen Events haben zwar eine Recurrence, aber repeats ist bei ihnen immer false.

Da jedes Event genehmigt und veröffentlicht werden muss bevor es angezeigt werden darf, gibt es für jedes Event ein State enum, der angibt ob es genehmigt, veröffentlicht ist usw. Jedes Event kann außerdem eine beliebige Anzahl an Revisions besitzen. Dabei handelt es sich eventuelle Änderungen. Es wird dann die letzte veröffentlichte Revision angezeigt, sonst das Event selbst, falls es veröffentlicht ist. Dies macht die Logik zum anzeigen, Filtern zwar besonders kompliziert, und obwohl in den Anforderungen kein Editieren von Events vorgesehen war, haben wir uns dafür entschieden dies zum implementieren. Dabei wurden abermals Annahmen getroffen: mit der Änderung eines Events, ist dieses nicht mehr Teil der Recurrence. Der Edit funktioniert folgendermaßen: da wir davon ausgehen, dass ein Event aus der Recurrence fliegt, wenn es editiert wird, wird ein neues Exclude angelegt. Aus dieser Annahme folgt auch, dass eine Editierung des ersten Elementes einer Recurrence alleine nicht erfolgen kann, da die Recurrence dann ohne Eigentümer da steht. Für den Fall dass das mal erfolgen soll wurde die Methode moveOwner des Recurrence Models vorbereitet. Jede Recurrence hat ein Event, namens Owner, von dem die Wiederholungen kopiert werden.

Ein Vorteil des gewählten Ansatzes ist, um die komplette Recurrence zu bearbeiten muss einfach nur der Owner einer Recurrence editiert werden. Der Editiervorgang wird eingeleitet, indem das Event per Deep Copy kopiert wird und als Revision des alten Events gespeichert wird. Dafür wird dieses Gem genutzt: https://github.com/moiristo/deep_cloneable sollte eine komplette Recurrence bearbeitet werden wird beim veröffentlichen, die alte Recurrence komplett unpubliziert. Und dann wird makeRecurr wieder aufgerufen. Eine genaue Prüfung nach Änderungen findet nicht statt. Es wurde zuerst den Workflow mittels Paper Trail zu implementieren. Leider stellte sich dieses Gem als unzureichend für unsere Zwecke heraus, da erstens in die Datenbank serialisiert würde und zweitens Paper Trail nur manchmal kopiert und so eine Rückverfolgung der einzelnen Versionen unmöglich wurde.

Das Anlegen eines neuen Kalendereintrags gestaltete sich als eine besondere Herausforderung: da unser Kalender Modell aus drei Models und deren Beziehungen besteht, macht zum Beispiel eine Recurrence ohne Event keinen Sinn. Das heißt es musste ein Einfacher Workflow gefunden werden, der diese Dinge sicherstellt. Es würde sich für das Anlegen eines Wizards entschieden. Dafür wurde das Gem Wicked genutzt. (https://github.com/schneems/wicked). Dies kann leider teilweise etwas schwierig sein. Das Gem braucht eine Event id zum arbeiten, das heißt es muss ein neues Event.create aufgerufen werden, ehe der Assistent aufgerufen werden kann. Das gibt ein weiteres Problem: Validations müssen für Teile des Wizards ausgeschaltet werden. Die Lösung ist teilweise etwas unschön, aber leider ließ sich der Wizard nicht mit Objekten, die nur im Session Objekt liegen betreiben und einige Lösungen übersteigen sicher unsere Kompetenzen im Bereich Rails.

Löschen ist System genauso geregelt wie das editieren: ein Manager und ein Admin müssen zustimmen. Das bedeutet abermals das wenn der Owner einer Recurrence gelöscht wird, die komplette Recurrence gelöscht wird. Ein sogenanntes unpublieren ist kein löschen an sich der State des Events wird nur auf nicht publiziert gesetzt. Dies lässt die Tür für eine Rollback Funktionalität später offen.

Es wird aufgrund dessen, dass mit jedem new und edit neue Records in der Datenbank angelegt werden, ein rake Task anzulegen, der einmal im Monat nicht abgeschickte Events löscht.